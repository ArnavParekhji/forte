import logging
from collections import defaultdict
from typing import (DefaultDict, Dict, List, Set, Type,
                    Hashable, Tuple, Union, Optional)

from forte.common.exception import PackIndexError
from forte.common.types import LinkType, GroupType, EntryType
from forte.data.ontology.top import (Entry, BaseGroup, Annotation, Span, Link,
                                     Group)

logger = logging.getLogger(__name__)


class BaseIndex:
    """
    A set of indexes used in a datapack:

    (1) :attr:`entry_index`,
    the index from each tid to the corresponding entry;

    (2) :attr:`type_index`, the index from each type to the entries of that
    type;

    (3) :attr:`component_index`, the index from each component to the
    entries generated by that component;

    (4) :attr:`link_index`, the index
    from child (:attr:`link_index["child_index"]`)and parent
    (:attr:`link_index["parent_index"]`) nodes to links;

    (5) :attr:`group_index`, the index from group members to groups.
    """

    def __init__(self):
        # basic indexes (switches always on)
        self.entry_index: Dict[str, Entry] = dict()
        self.type_index: DefaultDict[Type, Set[str]] = defaultdict(set)
        self.component_index: DefaultDict[str, Set[str]] = defaultdict(set)

        # other indexes (built when first looked up)
        self._group_index = defaultdict(set)
        self._link_index: Dict[str, DefaultDict[Hashable, set]] = dict()
        # indexing switches
        self._group_index_switch = False
        self._link_index_switch = False

    def update_basic_index(self, entries: List[Entry]):
        """Build or update the basic indexes, including

        (1) :attr:`entry_index`,
        the index from each tid to the corresponding entry;

        (2) :attr:`type_index`, the index from each type to the entries of that
        type;

        (3) :attr:`component_index`, the index from each component to the
        entries generated by that component.

        Args:
            entries (list): a list of entires to be added into the basic index.
        """
        for entry in entries:
            self.entry_index[entry.tid] = entry
            self.type_index[type(entry)].add(entry.tid)
            self.component_index[entry.component].add(entry.tid)

    @property
    def link_index_switch(self):
        return self._link_index_switch

    def turn_link_index_switch(self, on: bool):
        self._link_index_switch = on

    @property
    def group_index_switch(self):
        return self._group_index_switch

    def turn_group_index_switch(self, on: bool):
        self._group_index_switch = on

    def build_link_index(self, links: List[LinkType]):
        """
        Build the :attr:`link_index`, the index from child and parent
        nodes to links. It will build the links with the links in the dataset.
        :attr:`link_index` consists of two sub-indexes:
        "child_index" is the index from child nodes to their corresponding
        links, and "parent_index" is the index from parent nodes to their
        corresponding links.
        Returns:

        """
        logger.debug("Building link index.")
        self.turn_group_index_switch(on=True)
        self._link_index["child_index"] = defaultdict(set)
        self._link_index["parent_index"] = defaultdict(set)
        self.update_link_index(links)

    def build_group_index(self, groups: List[GroupType]):
        """
        Build :attr:`group_index`, the index from group members to groups.
        Returns:

        """
        logger.debug("Building group index.")
        self.turn_group_index_switch(on=True)
        self._group_index = defaultdict(set)
        self.update_group_index(groups)

    def link_index(self, tid: str, as_parent: bool = True) -> Set[str]:
        """
        Look up the link_index with key ``tid``. If the link index is not built,
        this will trigger the building process and subsequent steps will be
        more efficient.

        Args:
            tid (str): the tid of the entry being looked up.
            as_parent (bool): If `as_patent` is True, will look up
                :attr:`link_index["parent_index"] and return the tids of links
                whose parent is `tid`. Otherwise,  will look up
                :attr:`link_index["child_index"] and return the tids of links
                whose child is `tid`.
        """
        if not self._link_index_switch:
            raise PackIndexError('Link index for pack not build')

        if as_parent:
            return self._link_index["parent_index"][tid]
        else:
            return self._link_index["child_index"][tid]

    def group_index(self, tid: str) -> Set[str]:
        """
        Look up the group_index with key `tid`.
        """
        if not self._group_index_switch:
            raise PackIndexError('Group index for pack not build')
        return self._group_index[tid]

    def update_link_index(self, links: List[LinkType]):
        """
        Update :attr:`link_index` with the provided links, the index from child
        and parent to links. :attr:`link_index` consists of two sub-indexes:
        "child_index" is the index from child nodes to their corresponding
        links, and "parent_index" is the index from parent nodes to their
        corresponding links.

        Args:
            links (list): a list of links to be added into the index.
        """
        logger.debug("Updating link index.")

        if not self._link_index:
            raise PackIndexError("Link index has not been built.")

        for link in links:
            self._link_index["child_index"][
                link.get_child().index_key
            ].add(link.tid)
            self._link_index["parent_index"][
                link.get_parent().index_key
            ].add(link.tid)

    def update_group_index(self, groups: List[GroupType]):
        """Build or update :attr:`group_index`, the index from group members
         to groups.

        Args:
            groups (list): a list of groups to be added into the index.
        """
        logger.debug("Updating group index")

        if not self._group_index:
            raise PackIndexError("Group index has not been built.")

        for group in groups:
            for member in group.members:
                self._group_index[member].add(group.tid)

    def add_link_parent(self, parent: Entry, link: LinkType):
        self._link_index["parent_index"][parent.index_key].add(link.tid)

    def add_link_child(self, child: Entry, link: LinkType):
        self._link_index["child_index"][child.index_key].add(link.tid)

    def add_group_member(self, member: Entry, group: BaseGroup):
        self._group_index[member.index_key].add(group.tid)


class DataIndex(BaseIndex):
    def __init__(self):
        super().__init__()
        self._coverage_index: Dict[Tuple[Type[Annotation], Type[EntryType]],
                                   Dict[str, Set[str]]] = dict()
        self._coverage_index_valid = True

    @property
    def coverage_index_is_valid(self):
        return self._coverage_index_valid

    def activate_coverage_index(self):
        self._coverage_index_valid = True

    def deactivate_coverage_index(self):
        self._coverage_index_valid = False

    def coverage_index(
            self,
            outter_type: Type[Annotation],
            inner_type: Type[EntryType]) -> Optional[Dict[str, Set[str]]]:
        if not self.coverage_index_is_valid:
            return None
        return self._coverage_index.get((outter_type, inner_type))

    def build_coverage_index(
            self,
            data_pack,
            outter_type: Type[Annotation],
            inner_type: Type[EntryType]
    ):
        if not self.coverage_index_is_valid:
            self._coverage_index = dict()

        # prevent the index from being used during construction
        self.deactivate_coverage_index()

        self._coverage_index[(outter_type, inner_type)] = dict()
        for range_annotation in self.data_pack.get_entries_by_type(outter_type):
            entries = self.data_pack.get_entries(inner_type, range_annotation)
            entry_ids = {e.tid for e in entries}
            self._coverage_index[(outter_type,
                                  inner_type)][range_annotation.tid] = entry_ids

        self.activate_coverage_index()

    def have_overlap(self,
                     entry1: Union[Annotation, str],
                     entry2: Union[Annotation, str]) -> bool:
        """Check whether the two annotations have overlap in span.

        Args:
            entry1 (str or Annotation): An :class:`Annotation` object to be
                checked, or the tid of the Annotation.
            entry2 (str or Annotation): Another :class:`Annotation` object to be
                checked, or the tid of the Annotation.
        """
        if isinstance(entry1, str):
            e = self.entry_index[entry1]
            if not isinstance(e, Annotation):
                raise TypeError(f"'entry1' should be an instance of Annotation,"
                                f" but get {type(e)}")
            entry1 = e

        if not isinstance(entry1, Annotation):
            raise TypeError(f"'entry1' should be an instance of Annotation,"
                            f" but get {type(entry1)}")

        if isinstance(entry2, str):
            e = self.entry_index[entry2]
            if not isinstance(e, Annotation):
                raise TypeError(f"'entry2' should be an instance of Annotation,"
                                f" but get {type(e)}")
            entry2 = e

        if not isinstance(entry2, Annotation):
            raise TypeError(f"'entry2' should be an instance of Annotation,"
                            f" but get {type(entry2)}")

        return not (entry1.span.begin >= entry2.span.end or
                    entry1.span.end <= entry2.span.begin)

    # TODO: How can inner_entry be a str?
    def in_span(self,
                inner_entry: Union[str, Entry],
                span: Span) -> bool:
        """Check whether the ``inner entry`` is within the given ``span``.
        Link entries are considered in a span if both the
        parent and the child are within the span. Group entries are
        considered in a span if all the members are within the span.

        Args:
            inner_entry (str or Entry): An :class:`Entry` object to be checked.
                We will check whether this entry is within ``span``.
            span (Span): A :class:`Span` object to be checked. We will check
                whether the ``inner_entry`` is within this span.
        """

        if isinstance(inner_entry, str):
            inner_entry = self.entry_index[inner_entry]

        if isinstance(inner_entry, Annotation):
            inner_begin = inner_entry.span.begin
            inner_end = inner_entry.span.end
        elif isinstance(inner_entry, Link):
            child = inner_entry.get_child()
            parent = inner_entry.get_parent()

            if (not isinstance(child, Annotation)
                    or not isinstance(parent, Annotation)):
                # Cannot check in_span for non-annotations.
                return False

            child_: Annotation = child
            parent_: Annotation = parent

            inner_begin = min(child_.span.begin, parent_.span.begin)
            inner_end = max(child_.span.end, parent_.span.end)
        elif isinstance(inner_entry, Group):
            inner_begin = -1
            inner_end = -1
            for mem in inner_entry.get_members():
                if not isinstance(mem, Annotation):
                    # Cannot check in_span for non-annotations.
                    return False

                mem_: Annotation = mem
                if inner_begin == -1:
                    inner_begin = mem_.span.begin
                inner_begin = min(inner_begin, mem_.span.begin)
                inner_end = max(inner_end, mem_.span.end)
        else:
            raise ValueError(
                f"Invalid entry type {type(inner_entry)}. A valid entry "
                f"should be an instance of Annotation, Link, or Group."
            )
        return inner_begin >= span.begin and inner_end <= span.end
